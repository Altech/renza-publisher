#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

$:.unshift File.expand_path('../lib', __dir__)

require 'renza-publisher'
require 'renza-publisher/image-processor'
require 'renza-publisher/path'

require 'fileutils'
require 'optparse'
require 'time'
require 'pp'
require 'json'

require 'colorize'


include FileUtils

begin
  input = Hash.new

  opt = OptionParser.new("使い方: renza-publisher-split -l <location> -t <time> [-d <disk-number>] <video-file>+")
  opt.on('-l LOCATION','--location', '動画が撮影された場所. e.g. 秋葉原レジャーランド') {|s| input[:location] = s}
  opt.on('-t TIME','--time', '動画が撮影された日時. e.g. "2012-10-03 15:00:00"') {|d| input[:time] = Time.parse(d)} 
  opt.on('-d NUMBER','--disk-number', '特定のディスクを処理する場合のディスク番号（1始まり）'){|n| input[:disk_number] = n.to_i if n}
  opt.parse!(ARGV)
  input[:videos] = ARGV.dup

  abort "撮影が行われた場所を-lオプションで指定してください" if input[:location].nil?
  abort "撮影が行われた日時を-tオプションで指定してください" if input[:time].nil?
  abort "動画ファイルを指定してください" if input[:videos].nil? or input[:videos].empty?
  abort "指定したファイルは存在しません" if not input[:videos].all?{|file| File.exists? file}
end


def input.each_video(&block)
  self[:videos].each_with_index do |src_video, i|
    disk_number = i + (self[:disk_number] ? self[:disk_number] : 1)
    output_dir  = "renza-#{self[:time].strftime("%Y-%m-%d")}"
    working_dir = output_dir + "/images-disk#{disk_number}"
    path = RenzaPublisher::Path.new(working_dir, output_dir, File.extname(src_video), disk_number)
    block.call(path, src_video, disk_number)
  end
end

# # 1. create images
input.each_video do |path, src_video, _|
  unless Dir.exists? path.working_dir and File.exists? path.image_file(1)
    puts "ffmpeg -i #{src_video} -r 1 -f image2 #{path.working_dir}/#{RenzaPublisher::Path::IMAGE_FORMAT}"
    puts `ffmpeg -i #{src_video} -r 1 -f image2 #{path.working_dir}/#{RenzaPublisher::Path::IMAGE_FORMAT}`
  end
end

# # 2. choose sample images and mask them
input.each_video do |path, _, _|
  unless File.exists? path.time_table_file or 
         (Dir.exists? path.sample_dir and path.sample_dir_include_all_samples? and path.sample_files.all?{|sample| RenzaPublisher::ImageProcessor.is_same_size? sample, path.image_file(1)})
    rm_r  path.sample_dir if Dir.exists? path.sample_dir
    mkdir path.sample_dir
    
    puts "imagesディレクトリからサンプル画像を3つsamplesディレクトリにコピーしてください。"
    puts "そのあと、それぞれを #{path.sample_basenames.map{|s| s + ".jpg"}.join(', ')} にリネームしてください。"
    `open #{path.sample_dir}`; sleep 0.5; `open #{path.working_dir}`
    sleep 0.5 until path.sample_dir_include_all_samples?
    puts "サンプル画像を確認しました。"
  end
end

# # 3. search begin-ends.
input.each_video do |path, _, _|
  samples = Hash[path.sample_basenames.map(&:to_sym).zip path.sample_files]
  RenzaPublisher::ImageProcessor.create_images_for_masking(path)

  unless File.exists? path.time_table_file
    result = Array.new
    i = 1
    loop do
      candidate = path.image_file(i)
      
      break if not File.exists? candidate
      
      if    RenzaPublisher::ImageProcessor.is_same?(samples[:beginning],   candidate, path.masking_file_for_beginning)
        puts "beginning: #{candidate}".blue
        result << [i]
        i += 70
      elsif RenzaPublisher::ImageProcessor.is_same?(samples[:ending_win],  candidate)
        puts "ending(win): #{candidate}".green
        result.last += [i,:win] if result.size > 0 and result.last.size == 1
        i += 10
      elsif RenzaPublisher::ImageProcessor.is_same?(samples[:ending_lose], candidate, path.masking_file_for_losing)
        puts "ending(lose): #{candidate}".green
        # 1秒前を指定
        result.last += [i-1,:lose] if result.size > 0 and result.last.size == 1
        i += 10
      else
        i += 1
      end
    end
    File.write(path.time_table_file, result.to_json)
  end
end

# # 4. split the movie.
input.each_video do |path, src_video, disk_number|
  result = JSON.parse(File.read(path.time_table_file))
  
  base = (1..(disk_number-1)).map{|previous_disk_number|
    abort "#{previous_disk_number}番目のディスクを先に処理してください" if not File.exists? path.time_table_file(previous_disk_number)
    JSON.parse(File.read(path.time_table_file(previous_disk_number))).select{|a| a.size == 3}.size
  }.reduce(0,&:+)
  
  result.select{|a| a.size == 3}.each_with_index do |times, i|
    next if File.exists? path.video_file(base+i+1) and File.exists? path.thumbnail_file(base+i+1)
    from, to, _ = times
    thumbnail = path.image_file(from+5)
    
    cp thumbnail, path.thumbnail_file(base+i+1)
    
    puts "ffmpeg -i \"#{src_video}\" -ss #{from-3} -t #{to-from+1} \"#{path.video_file(base+i+1)}\""
    puts `ffmpeg -i "#{src_video}"   -ss #{from-3} -t #{to-from+1}  "#{path.video_file(base+i+1)}"`

  end

  metadata = File.exists?(path.metadata_file) ? JSON.parse(File.read(path.metadata_file)) : Hash.new
  metadata['win_or_lose'] ||= Array.new
  result.select{|a| a.size == 3}.map(&:last).each_with_index do |win_or_lose,i|
    metadata['win_or_lose'][base+i] = win_or_lose
  end

  metadata.merge!({'location' => input[:location], 'time' => input[:time]})

  File.write(path.metadata_file, metadata.to_json)
end
